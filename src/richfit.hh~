/*	richfit.hh	*/
//C Copyright (C) 2015 Richard TjÃ¶rnhammar
//L
//L  This library is free software and is distributed under the terms
//L  and conditions of version 2.1 of the GNU Lesser General Public
//L  Licence (LGPL) with the following additional clause:
//L
//L     `You may also combine or link a "work that uses the Library" to
//L     produce a work containing portions of the Library, and distribute
//L     that work under terms of your choice, provided that you give
//L     prominent notice with each copy of the work that the specified
//L     version of the Library is used in it, and that you include or
//L     provide public access to the complete corresponding
//L     machine-readable source code for the Library including whatever
//L     changes were used in the work. (i.e. If you make changes to the
//L     Library you must distribute those, but you do not need to
//L     distribute source or object code to those portions of the work
//L     not covered by this licence.)'
//L
//L  Note that this clause grants an additional right and does not impose
//L  any additional restriction, and so does not affect compatibility
//L  with the GNU General Public Licence (GPL). If you wish to negotiate
//L  other terms, please contact the maintainer.
//L
//L  You can redistribute it and/or modify the library under the terms of
//L  the GNU Lesser General Public License as published by the Free Software
//L  Foundation; either version 2.1 of the License, or (at your option) any
//L  later version.
//L
//L  This library is distributed in the hope that it will be useful, but
//L  WITHOUT ANY WARRANTY; without even the implied warranty of
//L  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//L  Lesser General Public License for more details.
//L
//L  You should have received a copy of the CCP4 licence and/or GNU
//L  Lesser General Public License along with this library; if not, write
//L  to the CCP4 Secretary, Daresbury Laboratory, Warrington WA4 4AD, UK.
//L  The GNU Lesser General Public can also be obtained by writing to the
//L  Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
//L  MA 02111-1307 USA

#include "richtypes.h"

namespace richanalysis {

  class simple_ops
  {
  public:
	ftyp square( ftyp x ) { return x*x; }
	ftyp abs( ftyp x ) { return (x>0)?(x):(-1*x); }
  };

  class clustering : public simple_ops
  {
  public:
    //! null constructor
	inline clustering() {} //!< Null constructor

    //! performs k-means clustering on the specified data
	int gsl_kmeans( gmat *, gvec *, gmat *, gvec * );

//	inline const ftyp& f() const { return f_; } 
  private:
    ftyp f_;
  };

  class tensorIO
  {
  public:
    //! null constructor
	inline tensorIO() {} //!< Null constructor

    //! Outputs a gsl matrix with label vector
	void output_matrix_label(gmat *m, gvec *v);

    //! Outputs a gsl matrix with label vector
	void output_matrix(gmat *M);

    //! Outputs a gsl vector
	void output_vector(gvec *v);

  private:
	ftyp f_;
  };


  class linalg : public simple_ops
  {
  public:
    //! Linear algebra routines needed for fitting
	ftyp	v_sum		( gvec *v );
	int	calc_centroid	( gmat *P , gvec *w , gvec *p0  );
	int 	calc_vmprod	( gvec *w , gmat *P , gmat *wP  );
	int	center_matrix	( gmat *P , gvec *p0 	);
	int	invert_matrix	( gmat *A , gmat *invA	);
	ftyp	get_det		( gmat *A );
  private:
	ftyp f_;
  };

  class fitting : public linalg 
  {
  public:
    //! null constructor
	inline	fitting() {} //!< Null constructor

    //! shape fitting
	ftyp	shape_fit_tot	( gmat *P , gmat *Q ,	// IN
				  gvec *w1, gvec *w2, 	// IN
				  gmat *U , gvec *t ,	// OUT 
				  int II );
    //! model alignment
	ftyp	kabsch_fit	( gmat *P	, gmat *Q , gvec *w,	// IN
				  gmat *U	, gvec *t );		// OUT
    //! apply the transformation
	void	apply_fit	( gmat *P	, gmat *U, gvec *t); 
	void	apply_fit	( particles px	, gmat *U, gvec *t); 

    //! invert transformation
	void	inver_fit	( gmat *U, gvec *t, gmat *invU, gvec *invt );

  private:
	ftyp f_;
  };

  class quaternion
  {
  public:
    //! constructor
	inline	quaternion() { bSet_=0;  q_= gsl_vector_alloc(4); gsl_vector_set_zero(q_); } //!< Null constructor
    //! 
	int	is_complete(){	return bSet_; }
	void	set_quat( const gvec *q0 ) { bSet_= q0->size==4?gsl_vector_memcpy( q_ , q0 )+1:0; }
	gvec*	get_quat() { return q_; }
	void	clear(void){ gsl_vector_set_zero(q_); bSet_=0; }
    //! class destructor
	~quaternion() {
    		gsl_vector_free(q_);
	};

    //! Routines for doing rotation
	int	assign_quaterion( gvec *x, ftyp angle );
	int	rotate_coord( gvec *x );
  private:
	int	bSet_;
	gvec 	*q_;
  };

}
